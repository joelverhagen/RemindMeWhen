<#@ template hostspecific="true" language="C#" #>
<#@ include file="MultipleOutputHelper.ttinclude" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Knapcode.RemindMeWhen.Core.Identities" #>
<#

var manager = Manager.Create(Host, GenerationEnvironment);

foreach(var pair in IdentityTemplate.AllMetadata)
{
	string name = pair.Key;
	manager.StartNewFile(name + ".cs");

	IdentityMetadata metadata = pair.Value;
	IdentityProperty[] properties = IdentityTemplate.GetIdentityProperties(metadata);

	var namespaces = new List<string>
	{
		"System",
		"System.Globalization",
		"Knapcode.RemindMeWhen.Core.Support"
	};

	foreach(Type type in pair.Value.FieldTypes)
	{
		namespaces.Add(type.Namespace);
	}

	namespaces = namespaces
		.Distinct()
		.OrderBy(n => !n.StartsWith("System"))
		.ThenBy(n => n)
		.ToList();

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#

	foreach(var n in namespaces)
	{
#>
using <#= n #>;
<#
	}
#>

namespace Knapcode.RemindMeWhen.Core.Identities
{
    public struct <#= name #> : IEquatable<<#= name #>>, IComparable<<#= name #>>
    {
        private static readonly IdentityMetadata Metadata = IdentityTemplate.<#= name #>Metadata;

<#
	foreach(var p in properties.OrderBy(p => p.FieldName))
	{
#>
        private readonly <#= p.TypeName #> <#= p.FieldName #>;
<#
	}
#>

        public <#= name #>(string identity)
        {
            Guard.ArgumentNotNull(identity, "identity");
            object[] fields;
            if (!Metadata.TryParse(identity, out fields))
            {
                string message = string.Format(
                    CultureInfo.InvariantCulture,
                    "The provided <#= name #> string '{0}' could not be parsed.",
                    identity);
                throw new ArgumentException(message);
            }

<#
	foreach(var p in properties)
	{
#>
            <#= p.FieldName #> = (<#= p.TypeName #>) fields[<#= p.Index #>];
<#
	}
#>
        }

        public <#= name #>(<# foreach(var p in properties) { Write(p.TypeName + " " + p.LocalName + p.Seperator); } #>)
        {
<#
	foreach(var p in properties.Where(p => !p.IsValueType))
	{
#>
            Guard.ArgumentNotNull(<#= p.LocalName #>, "<#= p.LocalName #>");
<#
	}
#>

<#
	foreach(var p in properties)
	{
#>
            <#= p.FieldName #> = <#= p.LocalName #>;
<#
	}
#>

            Metadata.ValidateFieldsAreParsable(Fields);
        }

<#
	foreach(var p in properties)
	{
#>
        public <#= p.TypeName #> <#= p.PropertyName #>
        {
            get { return <#= p.FieldName #>; }
        }

<#
	}
#>
        private object[] Fields
        {
            get { return new object[] {<# foreach(var p in properties) { Write(p.PropertyName + p.Seperator); } #>}; }
        }

        public int CompareTo(<#= name #> other)
        {
            return Metadata.CompareTo(Fields, other.Fields);
        }

        public bool Equals(<#= name #> other)
        {
            return Metadata.Equals(Fields, other.Fields);
        }

        public bool TryParse(string input, out <#= name #> output)
        {
            object[] fields;
            if (!Metadata.TryParse(input, out fields))
            {
                output = default(<#= name #>);
                return false;
            }

            output = new <#= name #>(<# foreach(var p in properties) { Write("(" + p.TypeName + ") fields[" + p.Index + "]" + p.Seperator); } #>);
            return true;
        }

        public override string ToString()
        {
            return Metadata.ToString(Fields);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            return obj is EventIdentity && Equals((EventIdentity) obj);
        }

        public override int GetHashCode()
        {
            return Metadata.GetHashCode(Fields);
        }
    }
}
<#
	manager.EndBlock();
}

manager.Process(true);
#>