//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using Knapcode.RemindMeWhen.Core.Models;
using Knapcode.RemindMeWhen.Core.Support;

namespace Knapcode.RemindMeWhen.Core.Identities
{
    public struct EventIdentity : IEquatable<EventIdentity>, IComparable<EventIdentity>
    {
        private static readonly IdentityMetadata Metadata = IdentityTemplate.EventIdentityMetadata;

        private readonly string _source;
        private readonly string _sourceIdentity;
        private readonly EventType _type;

        public EventIdentity(string identity)
        {
            Guard.ArgumentNotNull(identity, "identity");
            object[] fields;
            if (!Metadata.TryParse(identity, out fields))
            {
                string message = string.Format(
                    CultureInfo.InvariantCulture,
                    "The provided EventIdentity string '{0}' could not be parsed.",
                    identity);
                throw new ArgumentException(message);
            }

            _type = (EventType) fields[0];
            _source = (string) fields[1];
            _sourceIdentity = (string) fields[2];
        }

        public EventIdentity(EventType type, string source, string sourceIdentity)
        {
            Guard.ArgumentNotNull(source, "source");
            Guard.ArgumentNotNull(sourceIdentity, "sourceIdentity");

            _type = type;
            _source = source;
            _sourceIdentity = sourceIdentity;

            Metadata.ValidateFieldsAreParsable(Fields);
        }

        public EventType Type
        {
            get { return _type; }
        }

        public string Source
        {
            get { return _source; }
        }

        public string SourceIdentity
        {
            get { return _sourceIdentity; }
        }

        private object[] Fields
        {
            get { return new object[] {Type, Source, SourceIdentity}; }
        }

        public int CompareTo(EventIdentity other)
        {
            return Metadata.CompareTo(Fields, other.Fields);
        }

        public bool Equals(EventIdentity other)
        {
            return Metadata.Equals(Fields, other.Fields);
        }

        public bool TryParse(string input, out EventIdentity output)
        {
            object[] fields;
            if (!Metadata.TryParse(input, out fields))
            {
                output = default(EventIdentity);
                return false;
            }

            output = new EventIdentity((EventType) fields[0], (string) fields[1], (string) fields[2]);
            return true;
        }

        public override string ToString()
        {
            return Metadata.ToString(Fields);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            return obj is EventIdentity && Equals((EventIdentity) obj);
        }

        public override int GetHashCode()
        {
            return Metadata.GetHashCode(Fields);
        }
    }
}
