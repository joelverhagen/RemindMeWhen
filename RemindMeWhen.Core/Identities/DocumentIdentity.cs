//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Globalization;
using Knapcode.RemindMeWhen.Core.Clients;
using Knapcode.RemindMeWhen.Core.Support;

namespace Knapcode.RemindMeWhen.Core.Identities
{
    public struct DocumentIdentity : IEquatable<DocumentIdentity>, IComparable<DocumentIdentity>
    {
        private static readonly IdentityMetadata Metadata = IdentityTemplate.DocumentIdentityMetadata;

        private readonly DocumentType _type;
        private readonly string _typeIdentity;

        public DocumentIdentity(string identity)
        {
            Guard.ArgumentNotNull(identity, "identity");
            object[] fields;
            if (!Metadata.TryParse(identity, out fields))
            {
                string message = string.Format(
                    CultureInfo.InvariantCulture,
                    "The provided DocumentIdentity string '{0}' could not be parsed.",
                    identity);
                throw new ArgumentException(message);
            }

            _type = (DocumentType) fields[0];
            _typeIdentity = (string) fields[1];
        }

        public DocumentIdentity(DocumentType type, string typeIdentity)
        {
            Guard.ArgumentNotNull(typeIdentity, "typeIdentity");

            _type = type;
            _typeIdentity = typeIdentity;

            Metadata.ValidateFieldsAreParsable(Fields);
        }

        public DocumentType Type
        {
            get { return _type; }
        }

        public string TypeIdentity
        {
            get { return _typeIdentity; }
        }

        private object[] Fields
        {
            get { return new object[] {Type, TypeIdentity}; }
        }

        public int CompareTo(DocumentIdentity other)
        {
            return Metadata.CompareTo(Fields, other.Fields);
        }

        public bool Equals(DocumentIdentity other)
        {
            return Metadata.Equals(Fields, other.Fields);
        }

        public bool TryParse(string input, out DocumentIdentity output)
        {
            object[] fields;
            if (!Metadata.TryParse(input, out fields))
            {
                output = default(DocumentIdentity);
                return false;
            }

            output = new DocumentIdentity((DocumentType) fields[0], (string) fields[1]);
            return true;
        }

        public override string ToString()
        {
            return Metadata.ToString(Fields);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            return obj is EventIdentity && Equals((EventIdentity) obj);
        }

        public override int GetHashCode()
        {
            return Metadata.GetHashCode(Fields);
        }
    }
}
